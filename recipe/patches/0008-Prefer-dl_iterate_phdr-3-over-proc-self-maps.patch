From 8ab3fb00ad8949ed5c5eeaa3dcbb26f87be4ba35 Mon Sep 17 00:00:00 2001
From: Nehal J Wani <nehaljw.kkd1@gmail.com>
Date: Sat, 16 Oct 2021 22:24:08 -0400
Subject: [PATCH 1/2] Rename ET_<> macros to EDGETYPE_<>

The ET_NONE macro conflicts with a macro by the same name in
/path/to/sysroot/usr/include/elf.h
---
 lib/circogen/circularinit.c   |  2 +-
 lib/common/const.h            | 14 ++++++------
 lib/common/postproc.c         |  2 +-
 lib/common/routespl.c         |  4 ++--
 lib/common/splines.c          |  4 ++--
 lib/common/utils.c            | 40 +++++++++++++++++------------------
 lib/dotgen/dotinit.c          |  2 +-
 lib/dotgen/dotsplines.c       | 40 +++++++++++++++++------------------
 lib/fdpgen/layout.c           | 14 ++++++------
 lib/neatogen/neatoinit.c      |  4 ++--
 lib/neatogen/neatosplines.c   | 32 ++++++++++++++--------------
 lib/osage/osageinit.c         |  4 ++--
 lib/patchwork/patchworkinit.c |  2 +-
 lib/sfdpgen/sfdpinit.c        |  4 ++--
 lib/twopigen/twopiinit.c      |  2 +-
 plugin/visio/VisioRender.cpp  |  6 +++---
 16 files changed, 88 insertions(+), 88 deletions(-)

diff --git a/lib/circogen/circularinit.c b/lib/circogen/circularinit.c
index 29b480973..45365cb08 100644
--- a/lib/circogen/circularinit.c
+++ b/lib/circogen/circularinit.c
@@ -61,7 +61,7 @@ static void circular_init_node_edge(graph_t * g)
 
 void circo_init_graph(graph_t * g)
 {
-    setEdgeType (g, ET_LINE);
+    setEdgeType (g, EDGETYPE_LINE);
     /* GD_ndim(g) = late_int(g,agfindattr(g,"dim"),2,2); */
     Ndim = GD_ndim(g) = 2;	/* The algorithm only makes sense in 2D */
     circular_init_node_edge(g);
diff --git a/lib/common/const.h b/lib/common/const.h
index 91fb98097..21e3dd5b9 100644
--- a/lib/common/const.h
+++ b/lib/common/const.h
@@ -262,13 +262,13 @@
  */
 
 /* edge types */
-#define ET_NONE 	(0 << 1)
-#define ET_LINE 	(1 << 1)
-#define ET_CURVED 	(2 << 1)
-#define ET_PLINE 	(3 << 1)
-#define ET_ORTHO 	(4 << 1)
-#define ET_SPLINE 	(5 << 1)
-#define ET_COMPOUND 	(6 << 1)
+#define EDGETYPE_NONE       (0 << 1)
+#define EDGETYPE_LINE       (1 << 1)
+#define EDGETYPE_CURVED     (2 << 1)
+#define EDGETYPE_PLINE      (3 << 1)
+#define EDGETYPE_ORTHO      (4 << 1)
+#define EDGETYPE_SPLINE     (5 << 1)
+#define EDGETYPE_COMPOUND   (6 << 1)
 
 /* New ranking is used */
 #define NEW_RANK    	(1 << 4)
diff --git a/lib/common/postproc.c b/lib/common/postproc.c
index 51fb5215b..2cba53429 100644
--- a/lib/common/postproc.c
+++ b/lib/common/postproc.c
@@ -398,7 +398,7 @@ countClusterLabels (Agraph_t* g)
  * TODO: interaction with spline=ortho
  */
   /* True if edges geometries were computed and this edge has a geometry */
-#define HAVE_EDGE(ep) ((et != ET_NONE) && (ED_spl(ep) != NULL))
+#define HAVE_EDGE(ep) ((et != EDGETYPE_NONE) && (ED_spl(ep) != NULL))
 
 static void addXLabels(Agraph_t * gp)
 {
diff --git a/lib/common/routespl.c b/lib/common/routespl.c
index fd0f8abf0..90f843191 100644
--- a/lib/common/routespl.c
+++ b/lib/common/routespl.c
@@ -1125,7 +1125,7 @@ makeStraightEdges(graph_t * g, edge_t** edges, int e_cnt, int et, splineInfo* si
     pointf dumb[4];
     node_t *n;
     node_t *head;
-    bool curved = et == ET_CURVED;
+    bool curved = et == EDGETYPE_CURVED;
     pointf perp;
     pointf del;
     edge_t *e0;
@@ -1184,7 +1184,7 @@ makeStraightEdges(graph_t * g, edge_t** edges, int e_cnt, int et, splineInfo* si
 		dumber[3 - j] = dumb[j];
 	    }
 	}
-	if (et == ET_PLINE) {
+	if (et == EDGETYPE_PLINE) {
 	    Ppoint_t pts[4];
 	    Ppolyline_t spl, line;
 
diff --git a/lib/common/splines.c b/lib/common/splines.c
index d0f8cd98c..47fb92cc8 100644
--- a/lib/common/splines.c
+++ b/lib/common/splines.c
@@ -1313,12 +1313,12 @@ edgeMidpoint (graph_t* g, edge_t * e)
     if (APPROXEQPT(p, q, MILLIPOINT)) { /* degenerate spline */
 	spf = p;
     }
-    else if ((et == ET_SPLINE) || (et == ET_CURVED)) {
+    else if ((et == EDGETYPE_SPLINE) || (et == EDGETYPE_CURVED)) {
 	d.x = (q.x + p.x) / 2.;
 	d.y = (p.y + q.y) / 2.;
 	spf = dotneato_closest(ED_spl(e), d);
     }
-    else {   /* ET_PLINE, ET_ORTHO or ET_LINE */
+    else {   /* EDGETYPE_PLINE, EDGETYPE_ORTHO or EDGETYPE_LINE */
 	spf = polylineMidpoint (ED_spl(e), &p, &q);
     }
 
diff --git a/lib/common/utils.c b/lib/common/utils.c
index cd0152864..0ab5ff7f4 100644
--- a/lib/common/utils.c
+++ b/lib/common/utils.c
@@ -1674,31 +1674,31 @@ static int edgeType(const char *s, int dflt)
     }
 
     if (*s == '0') { /* false */
-	return ET_LINE;
+	return EDGETYPE_LINE;
     } else if (*s >= '1' && *s <= '9') { /* true */
-	return ET_SPLINE;
+	return EDGETYPE_SPLINE;
     } else if (strcasecmp(s, "curved") == 0) {
-	return ET_CURVED;
+	return EDGETYPE_CURVED;
     } else if (strcasecmp(s, "compound") == 0) {
-	return ET_COMPOUND;
+	return EDGETYPE_COMPOUND;
     } else if (strcasecmp(s, "false") == 0) {
-	return ET_LINE;
+	return EDGETYPE_LINE;
     } else if (strcasecmp(s, "line") == 0) {
-	return ET_LINE;
+	return EDGETYPE_LINE;
     } else if (strcasecmp(s, "none") == 0) {
-	return ET_NONE;
+	return EDGETYPE_NONE;
     } else if (strcasecmp(s, "no") == 0) {
-	return ET_LINE;
+	return EDGETYPE_LINE;
     } else if (strcasecmp(s, "ortho") == 0) {
-	return ET_ORTHO;
+	return EDGETYPE_ORTHO;
     } else if (strcasecmp(s, "polyline") == 0) {
-	return ET_PLINE;
+	return EDGETYPE_PLINE;
     } else if (strcasecmp(s, "spline") == 0) {
-	return ET_SPLINE;
+	return EDGETYPE_SPLINE;
     } else if (strcasecmp(s, "true") == 0) {
-	return ET_SPLINE;
+	return EDGETYPE_SPLINE;
     } else if (strcasecmp(s, "yes") == 0) {
-	return ET_SPLINE;
+	return EDGETYPE_SPLINE;
     }
 
     agerr(AGWARN, "Unknown \"splines\" value: \"%s\" - ignored\n", s);
@@ -1710,12 +1710,12 @@ static int edgeType(const char *s, int dflt)
  * If the attribute is not defined, use default.
  * If the attribute is "", use NONE.
  * If attribute value matches (case indepedent), use match.
- *   ortho => ET_ORTHO
- *   none => ET_NONE
- *   line => ET_LINE
- *   polyline => ET_PLINE
- *   spline => ET_SPLINE
- * If attribute is boolean, true means ET_SPLINE, false means ET_LINE.
+ *   ortho => EDGETYPE_ORTHO
+ *   none => EDGETYPE_NONE
+ *   line => EDGETYPE_LINE
+ *   polyline => EDGETYPE_PLINE
+ *   spline => EDGETYPE_SPLINE
+ * If attribute is boolean, true means EDGETYPE_SPLINE, false means EDGETYPE_LINE.
  * Else warn and use default.
  */
 void setEdgeType (graph_t* g, int dflt)
@@ -1727,7 +1727,7 @@ void setEdgeType (graph_t* g, int dflt)
 	et = dflt;
     }
     else if (*s == '\0') {
-	et = ET_NONE;
+	et = EDGETYPE_NONE;
     }
     else et = edgeType (s, dflt);
     GD_flags(g) |= et;
diff --git a/lib/dotgen/dotinit.c b/lib/dotgen/dotinit.c
index 45df01373..56523814a 100644
--- a/lib/dotgen/dotinit.c
+++ b/lib/dotgen/dotinit.c
@@ -284,7 +284,7 @@ static void dotLayout(Agraph_t * g)
     aspect_t* asp;
     int maxphase = late_int(g, agfindgraphattr(g,"phase"), -1, 1);
 
-    setEdgeType (g, ET_SPLINE);
+    setEdgeType (g, EDGETYPE_SPLINE);
     asp = setAspect (g, &aspect);
 
     dot_init_subg(g,g);
diff --git a/lib/dotgen/dotsplines.c b/lib/dotgen/dotsplines.c
index 415b7bd9b..a4ae2f8a7 100644
--- a/lib/dotgen/dotsplines.c
+++ b/lib/dotgen/dotsplines.c
@@ -324,15 +324,15 @@ static void _dot_splines(graph_t * g, int normalize)
     fwdedgea.out.base.data = (Agrec_t*)&fwdedgeai;
     fwdedgeb.out.base.data = (Agrec_t*)&fwdedgebi;
 
-    if (et == ET_NONE) return; 
-    if (et == ET_CURVED) {
+    if (et == EDGETYPE_NONE) return;
+    if (et == EDGETYPE_CURVED) {
 	resetRW (g);
 	if (GD_has_labels(g->root) & EDGE_LABEL) {
 	    agerr (AGWARN, "edge labels with splines=curved not supported in dot - use xlabels\n");
 	}
     } 
 #ifdef ORTHO
-    if (et == ET_ORTHO) {
+    if (et == EDGETYPE_ORTHO) {
 	resetRW (g);
 	if (GD_has_labels(g->root) & EDGE_LABEL) {
 	    setEdgeLabelPos (g);
@@ -427,7 +427,7 @@ static void _dot_splines(graph_t * g, int normalize)
     P->boxes = N_NEW(n_nodes + 20 * 2 * NSUB, boxf);
     sd.Rank_box = N_NEW(i, boxf);
 
-    if (et == ET_LINE) {
+    if (et == EDGETYPE_LINE) {
     /* place regular edge labels */
 	for (n = GD_nlist(g); n; n = ND_next(n)) {
 	    if (ND_node_type(n) == VIRTUAL && ND_label(n)) {
@@ -472,7 +472,7 @@ static void _dot_splines(graph_t * g, int normalize)
 		break;
 	}
 
-	if (et == ET_CURVED) {
+	if (et == EDGETYPE_CURVED) {
 	    int ii;
 	    edge_t* e0;
 	    edge_t** edgelist;
@@ -560,9 +560,9 @@ finish :
     /* end vladimir */
 
 #ifdef ORTHO
-    if (et != ET_ORTHO && et != ET_CURVED)  {
+    if (et != EDGETYPE_ORTHO && et != EDGETYPE_CURVED)  {
 #else
-    if (et != ET_CURVED) {
+    if (et != EDGETYPE_CURVED) {
 #endif
 	free(edges);
 	free(P->boxes);
@@ -1120,7 +1120,7 @@ makeSimpleFlatLabels (node_t* tn, node_t* hn, edge_t** edges, int ind, int cnt,
 	}
 	poly.pn = 8;
 	poly.ps = (Ppoint_t*)points;
-	ps = simpleSplineRoute (tp, hp, poly, &pn, et == ET_PLINE);
+	ps = simpleSplineRoute (tp, hp, poly, &pn, et == EDGETYPE_PLINE);
 	if (pn == 0) return;
 	ED_label(e)->pos.x = ctrx;
 	ED_label(e)->pos.y = ctry;
@@ -1172,7 +1172,7 @@ makeSimpleFlatLabels (node_t* tn, node_t* hn, edge_t** edges, int ind, int cnt,
 	}
 	poly.pn = 8;
 	poly.ps = (Ppoint_t*)points;
-	ps = simpleSplineRoute (tp, hp, poly, &pn, et == ET_PLINE);
+	ps = simpleSplineRoute (tp, hp, poly, &pn, et == EDGETYPE_PLINE);
 	if (pn == 0) return;
 	clip_and_install(e, aghead(e), ps, pn, &sinfo);
     }
@@ -1199,13 +1199,13 @@ makeSimpleFlat (node_t* tn, node_t* hn, edge_t** edges, int ind, int cnt, int et
     for (i = 0; i < cnt; i++) {
 	e = edges[ind + i];
 	pointn = 0;
-	if (et == ET_SPLINE || et == ET_LINE) {
+	if (et == EDGETYPE_SPLINE || et == EDGETYPE_LINE) {
 	    points[pointn++] = tp;
 	    points[pointn++] = pointfof((2 * tp.x + hp.x) / 3, dy);
 	    points[pointn++] = pointfof((2 * hp.x + tp.x) / 3, dy);
 	    points[pointn++] = hp;
 	}
-	else {   /* ET_PLINE */
+	else {   /* EDGETYPE_PLINE */
 	    points[pointn++] = tp;
 	    points[pointn++] = tp;
 	    points[pointn++] = pointfof((2 * tp.x + hp.x) / 3, dy);
@@ -1442,7 +1442,7 @@ make_flat_labeled_edge(graph_t* g, spline_info_t* sp, path* P, edge_t* e, int et
     ED_label(e)->pos = ND_coord(ln);
     ED_label(e)->set = TRUE;
 
-    if (et == ET_LINE) {
+    if (et == EDGETYPE_LINE) {
 	pointf startp, endp, lp;
 
 	startp = add_pointf(ND_coord(tn), ED_tail_port(e).p);
@@ -1483,7 +1483,7 @@ make_flat_labeled_edge(graph_t* g, spline_info_t* sp, path* P, edge_t* e, int et
 	for (size_t j = 0; j < boxn; j++) add_box(P, boxes[j]);
 	for (i = hend.boxn - 1; i >= 0; i--) add_box(P, hend.boxes[i]);
 
-	if (et == ET_SPLINE) ps = routesplines(P, &pn);
+	if (et == EDGETYPE_SPLINE) ps = routesplines(P, &pn);
 	else ps = routepolylines(P, &pn);
 	if (pn == 0) return;
     }
@@ -1609,7 +1609,7 @@ make_flat_edge(graph_t* g, spline_info_t* sp, path * P, edge_t ** edges, int ind
 	return;
     }
 
-    if (et == ET_LINE) {
+    if (et == EDGETYPE_LINE) {
 	makeSimpleFlat (agtail(e), aghead(e), edges, ind, cnt, et);
 	return;
     }
@@ -1618,7 +1618,7 @@ make_flat_edge(graph_t* g, spline_info_t* sp, path * P, edge_t ** edges, int ind
     hside = ED_head_port(e).side;
     if ((tside == BOTTOM && hside != TOP) ||
         (hside == BOTTOM && tside != TOP)) {
-	make_flat_bottom_edges (g, sp, P, edges, ind, cnt, e, et == ET_SPLINE);
+	make_flat_bottom_edges (g, sp, P, edges, ind, cnt, e, et == EDGETYPE_SPLINE);
 	return;
     }
 
@@ -1672,7 +1672,7 @@ make_flat_edge(graph_t* g, spline_info_t* sp, path * P, edge_t ** edges, int ind
 	for (size_t k = 0; k < boxn; k++) add_box(P, boxes[k]);
 	for (j = hend.boxn - 1; j >= 0; j--) add_box(P, hend.boxes[j]);
 
-	if (et == ET_SPLINE) ps = routesplines(P, &pn);
+	if (et == EDGETYPE_SPLINE) ps = routesplines(P, &pn);
 	else ps = routepolylines(P, &pn);
 	if (pn == 0)
 	    return;
@@ -1842,10 +1842,10 @@ make_regular_edge(graph_t* g, spline_info_t* sp, path * P, edge_t ** edges, int
 
     /* compute the spline points for the edge */
 
-    if ((et == ET_LINE) && (pointn = makeLineEdge (g, fe, pointfs, &hn))) {
+    if ((et == EDGETYPE_LINE) && (pointn = makeLineEdge (g, fe, pointfs, &hn))) {
     }
     else {
-	bool is_spline = et == ET_SPLINE;
+	bool is_spline = et == EDGETYPE_SPLINE;
 	boxes_t boxes = {0};
 	pointn = 0;
 	segfirst = e;
@@ -1891,7 +1891,7 @@ make_regular_edge(graph_t* g, spline_info_t* sp, path * P, edge_t ** edges, int
 	    if (is_spline) ps = routesplines(P, &pn);
 	    else {
 		ps = routepolylines (P, &pn);
-		if ((et == ET_LINE) && (pn > 4)) {
+		if ((et == EDGETYPE_LINE) && (pn > 4)) {
 		    ps[1] = ps[0];
 		    ps[3] = ps[2] = ps[pn-1];
 		    pn = 4;
@@ -1942,7 +1942,7 @@ make_regular_edge(graph_t* g, spline_info_t* sp, path * P, edge_t ** edges, int
 	boxes_free(&boxes);
 	if (is_spline) ps = routesplines(P, &pn);
 	else ps = routepolylines (P, &pn);
-	if (et == ET_LINE && pn > 4) {
+	if (et == EDGETYPE_LINE && pn > 4) {
 	    /* Here we have used the polyline case to handle
 	     * an edge between two nodes on adjacent ranks. If the
 	     * results really is a polyline, straighten it.
diff --git a/lib/fdpgen/layout.c b/lib/fdpgen/layout.c
index 2814a9fcd..efb743dd1 100644
--- a/lib/fdpgen/layout.c
+++ b/lib/fdpgen/layout.c
@@ -1030,7 +1030,7 @@ mkClusters (graph_t * g, clist_t* pclist, graph_t* parent)
 
 static void fdp_init_graph(Agraph_t * g)
 {
-    setEdgeType (g, ET_LINE);
+    setEdgeType (g, EDGETYPE_LINE);
     GD_alg(g) = NEW(gdata);	/* freed in cleanup_graph */
     GD_ndim(g) = late_int(g, agattr(g,AGRAPH, "dim", NULL), 2, 2);
     Ndim = GD_ndim(g) = MIN(GD_ndim(g), MAXDIM);
@@ -1067,18 +1067,18 @@ fdpSplines (graph_t * g)
     int trySplines = 0;
     int et = EDGE_TYPE(g);
 
-    if (et > ET_ORTHO) {
-	if (et == ET_COMPOUND) {
-	    trySplines = splineEdges(g, compoundEdges, ET_SPLINE);
+    if (et > EDGETYPE_ORTHO) {
+	if (et == EDGETYPE_COMPOUND) {
+	    trySplines = splineEdges(g, compoundEdges, EDGETYPE_SPLINE);
 	    /* When doing the edges again, accept edges done by compoundEdges */
 	    if (trySplines)
 		Nop = 2;
 	}
-	if (trySplines || et != ET_COMPOUND) {
+	if (trySplines || et != EDGETYPE_COMPOUND) {
 	    if (HAS_CLUST_EDGE(g)) {
 		agerr(AGWARN,
 		      "splines and cluster edges not supported - using line segments\n");
-		et = ET_LINE;
+		et = EDGETYPE_LINE;
 	    } else {
 		spline_edges1(g, et);
 	    }
@@ -1100,7 +1100,7 @@ void fdp_layout(graph_t * g)
     }
     neato_set_aspect(g);
 
-    if (EDGE_TYPE(g) != ET_NONE) fdpSplines (g); 
+    if (EDGE_TYPE(g) != EDGETYPE_NONE) fdpSplines (g);
 
     gv_postprocess(g, 0);
     PSinputscale = save_scale;
diff --git a/lib/neatogen/neatoinit.c b/lib/neatogen/neatoinit.c
index 975dd9ef5..a7168df23 100644
--- a/lib/neatogen/neatoinit.c
+++ b/lib/neatogen/neatoinit.c
@@ -606,7 +606,7 @@ static void neato_init_graph (Agraph_t * g)
 {
     int outdim;
 
-    setEdgeType (g, ET_LINE);
+    setEdgeType (g, EDGETYPE_LINE);
     outdim = late_int(g, agfindgraphattr(g, "dimen"), 2, 2);
     GD_ndim(agroot(g)) = late_int(g, agfindgraphattr(g, "dim"), outdim, 2);
     Ndim = GD_ndim(g->root) = MIN(GD_ndim(g->root), MAXDIM);
@@ -1459,7 +1459,7 @@ void neato_layout(Agraph_t * g)
 		    nodeInduce(gc);
 		    neatoLayout(g, gc, layoutMode, model, &am);
 		    removeOverlapWith(gc, &am);
-		    setEdgeType (gc, ET_LINE);
+		    setEdgeType (gc, EDGETYPE_LINE);
 		    if (noTranslate) doEdges(gc);
 		    else spline_edges(gc);
 		}
diff --git a/lib/neatogen/neatosplines.c b/lib/neatogen/neatosplines.c
index b4fe04ea4..9c9a69196 100644
--- a/lib/neatogen/neatosplines.c
+++ b/lib/neatogen/neatosplines.c
@@ -546,7 +546,7 @@ void makeSpline(graph_t* g, edge_t * e, Ppoly_t ** obs, int npoly, boolean chkPt
  * remain in the cluster's bounding box and, conversely, a cluster's box
  * is not altered to reflect intra-cluster edges.
  * If Nop > 1 and the spline exists, it is just copied.
- * NOTE: if edgetype = ET_NONE, we shouldn't be here.
+ * NOTE: if edgetype = EDGETYPE_NONE, we shouldn't be here.
  */
 static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
 {
@@ -566,10 +566,10 @@ static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
 #endif
     
     /* build configuration */
-    if (edgetype >= ET_PLINE) {
+    if (edgetype >= EDGETYPE_PLINE) {
 	obs = N_NEW(agnnodes(g), Ppoly_t *);
 	for (n = agfstnode(g); n; n = agnxtnode(g, n)) {
-	    obp = makeObstacle(n, pmargin, edgetype == ET_ORTHO);
+	    obp = makeObstacle(n, pmargin, edgetype == EDGETYPE_ORTHO);
 	    if (obp) {
 		ND_lim(n) = i; 
 		obs[i++] = obp;
@@ -583,10 +583,10 @@ static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
     npoly = i;
     if (obs) {
 	if ((legal = Plegal_arrangement(obs, npoly))) {
-	    if (edgetype != ET_ORTHO) vconfig = Pobsopen(obs, npoly);
+	    if (edgetype != EDGETYPE_ORTHO) vconfig = Pobsopen(obs, npoly);
 	}
 	else {
-	    if (edgetype == ET_ORTHO)
+	    if (edgetype == EDGETYPE_ORTHO)
 		agerr(AGWARN, "the bounding boxes of some nodes touch - falling back to straight line edges\n");
 	    else 
 		agerr(AGWARN, "some nodes with margin (%.02f,%.02f) touch - falling back to straight line edges\n", pmargin->x, pmargin->y);
@@ -596,8 +596,8 @@ static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
     /* route edges  */
     if (Verbose)
 	fprintf(stderr, "Creating edges using %s\n",
-	    (legal && edgetype == ET_ORTHO) ? "orthogonal lines" :
-	    (vconfig ? (edgetype == ET_SPLINE ? "splines" : "polylines") : 
+	    (legal && edgetype == EDGETYPE_ORTHO) ? "orthogonal lines" :
+	    (vconfig ? (edgetype == EDGETYPE_SPLINE ? "splines" : "polylines") :
 		"line segments"));
     if (vconfig) {
 	/* path-finding pass */
@@ -608,7 +608,7 @@ static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
 	}
     }
 #ifdef ORTHO
-    else if (legal && edgetype == ET_ORTHO) {
+    else if (legal && edgetype == EDGETYPE_ORTHO) {
 	orthoEdges (g, 0);
 	useEdges = 1;
     }
@@ -631,7 +631,7 @@ static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
 		    P->boxes = N_NEW(agnnodes(g) + 20 * 2 * 9, boxf);
 		}
 		makeSelfArcs(P, e, GD_nodesep(g->root));
-	    } else if (vconfig) { /* ET_SPLINE or ET_PLINE */
+	    } else if (vconfig) { /* EDGETYPE_SPLINE or EDGETYPE_PLINE */
 #ifdef HAVE_GTS
 		if (ED_count(e) > 1 || BOUNDARY_PORT(e)) {
 		    int fail = 0;
@@ -640,7 +640,7 @@ static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
 			makeStraightEdge(g, e, edgetype, &sinfo);
 		    else { 
 			if (!rtr) rtr = mkRouter (obs, npoly);
-			fail = makeMultiSpline(g, e, rtr, edgetype == ET_PLINE);
+			fail = makeMultiSpline(g, e, rtr, edgetype == EDGETYPE_PLINE);
 		    } 
 		    if (!fail) continue;
 		}
@@ -653,7 +653,7 @@ static int _spline_edges(graph_t * g, expand_t* pmargin, int edgetype)
 		if (Concentrate) cnt = 1; /* only do representative */
 		e0 = e;
 		for (i = 0; i < cnt; i++) {
-		    if (edgetype == ET_SPLINE)
+		    if (edgetype == EDGETYPE_SPLINE)
 			makeSpline(g, e0, obs, npoly, TRUE);
 		    else
 			makePolyline(g, e0);
@@ -771,13 +771,13 @@ void spline_edges0(graph_t * g, boolean set_aspect)
 {
     int et = EDGE_TYPE (g);
     if (set_aspect) neato_set_aspect(g);
-    if (et == ET_NONE) return;
+    if (et == EDGETYPE_NONE) return;
 #ifndef ORTHO
-    if (et == ET_ORTHO) {
+    if (et == EDGETYPE_ORTHO) {
 	agerr (AGWARN, "Orthogonal edges not yet supported\n");
-	et = ET_PLINE; 
-	GD_flags(g->root) &= ~ET_ORTHO;
-	GD_flags(g->root) |= ET_PLINE;
+	et = EDGETYPE_PLINE;
+	GD_flags(g->root) &= ~EDGETYPE_ORTHO;
+	GD_flags(g->root) |= EDGETYPE_PLINE;
     }
 #endif
     spline_edges1(g, et);
diff --git a/lib/osage/osageinit.c b/lib/osage/osageinit.c
index cadca6499..1f8b78459 100644
--- a/lib/osage/osageinit.c
+++ b/lib/osage/osageinit.c
@@ -63,7 +63,7 @@ static void cluster_init_graph(graph_t * g)
     Agnode_t *n;
     Agedge_t *e;
 
-    setEdgeType (g, ET_LINE);
+    setEdgeType (g, EDGETYPE_LINE);
     Ndim = GD_ndim(g)=2;	/* The algorithm only makes sense in 2D */
 
     for (n = agfstnode(g); n; n = agnxtnode(g, n)) {
@@ -364,7 +364,7 @@ void osage_layout(Agraph_t *g)
     }
     else {
 	int et = EDGE_TYPE (g);
-	if (et != ET_NONE) spline_edges1(g, et);
+	if (et != EDGETYPE_NONE) spline_edges1(g, et);
     }
     dotneato_postprocess(g);
 }
diff --git a/lib/patchwork/patchworkinit.c b/lib/patchwork/patchworkinit.c
index b01d20173..11a853b46 100644
--- a/lib/patchwork/patchworkinit.c
+++ b/lib/patchwork/patchworkinit.c
@@ -126,7 +126,7 @@ static void patchwork_init_node_edge(graph_t * g)
 static void patchwork_init_graph(graph_t * g)
 {
     N_shape = agattr(g, AGNODE, "shape","box");
-    setEdgeType (g, ET_LINE);
+    setEdgeType (g, EDGETYPE_LINE);
     /* GD_ndim(g) = late_int(g,agfindattr(g,"dim"),2,2); */
     Ndim = GD_ndim(g) = 2;	/* The algorithm only makes sense in 2D */
     mkClusters(g, NULL, g);
diff --git a/lib/sfdpgen/sfdpinit.c b/lib/sfdpgen/sfdpinit.c
index 3eb0fd9ea..d2e061a62 100644
--- a/lib/sfdpgen/sfdpinit.c
+++ b/lib/sfdpgen/sfdpinit.c
@@ -47,7 +47,7 @@ static void sfdp_init_graph(Agraph_t * g)
 {
     int outdim;
 
-    setEdgeType(g, ET_LINE);
+    setEdgeType(g, EDGETYPE_LINE);
     outdim = late_int(g, agfindgraphattr(g, "dimen"), 2, 2);
     GD_ndim(agroot(g)) = late_int(g, agfindgraphattr(g, "dim"), outdim, 2);
     Ndim = GD_ndim(agroot(g)) = MIN(GD_ndim(agroot(g)), MAXDIM);
@@ -327,7 +327,7 @@ void sfdp_layout(graph_t * g)
 		nodeInduce(sg);
 		sfdpLayout(sg, ctrl, hops, pad);
 		if (doAdjust) removeOverlapWith(sg, &am);
-		setEdgeType(sg, ET_LINE);
+		setEdgeType(sg, EDGETYPE_LINE);
 		spline_edges(sg);
 	    }
 	    packSubgraphs(ncc, ccs, g, &pinfo);
diff --git a/lib/twopigen/twopiinit.c b/lib/twopigen/twopiinit.c
index ef823dbc5..f2829de1b 100644
--- a/lib/twopigen/twopiinit.c
+++ b/lib/twopigen/twopiinit.c
@@ -50,7 +50,7 @@ static void twopi_init_node_edge(graph_t * g)
 
 void twopi_init_graph(graph_t * g)
 {
-    setEdgeType (g, ET_LINE);
+    setEdgeType (g, EDGETYPE_LINE);
     /* GD_ndim(g) = late_int(g,agfindgraphattr(g,"dim"),2,2); */
 	Ndim = GD_ndim(g)=2;	/* The algorithm only makes sense in 2D */
     twopi_init_node_edge(g);
diff --git a/plugin/visio/VisioRender.cpp b/plugin/visio/VisioRender.cpp
index 5311f17fc..2490958c6 100644
--- a/plugin/visio/VisioRender.cpp
+++ b/plugin/visio/VisioRender.cpp
@@ -370,9 +370,9 @@ namespace Visio
 			gvputs(job, "</Misc>\n");
 			
 			gvputs(job, "<Layout>\n");
-			gvprintf(job, "<ShapeRouteStyle>%d</ShapeRouteStyle>\n", edgeType == ET_LINE ? LORouteCenterToCenter : LORouteRightAngle);
+			gvprintf(job, "<ShapeRouteStyle>%d</ShapeRouteStyle>\n", edgeType == EDGETYPE_LINE ? LORouteCenterToCenter : LORouteRightAngle);
 			gvputs(job, "<ConFixedCode>6</ConFixedCode>\n");
-			gvprintf(job, "<ConLineRouteExt>%d</ConLineRouteExt>\n", edgeType == ET_LINE || edgeType == ET_PLINE ? LORouteExtStraight : LORouteExtNURBS);
+			gvprintf(job, "<ConLineRouteExt>%d</ConLineRouteExt>\n", edgeType == EDGETYPE_LINE || edgeType == EDGETYPE_PLINE ? LORouteExtStraight : LORouteExtNURBS);
 			gvputs(job, "<ShapeSplittable>1</ShapeSplittable>\n");
 			gvputs(job, "</Layout>\n");
 			
@@ -436,7 +436,7 @@ namespace Visio
 			PrintTexts(job);
 			
 			/* output Line, Fill, Geom */
-			graphic.Print(job, first, last, edgeType != ET_LINE && edgeType != ET_PLINE);
+			graphic.Print(job, first, last, edgeType != EDGETYPE_LINE && edgeType != EDGETYPE_PLINE);
 			
 			gvputs(job, "</Shape>\n");
 			return true;
-- 
GitLab


From 5cad66c155863f5c9212bb997de2768d72efc0b7 Mon Sep 17 00:00:00 2001
From: Nehal J Wani <nehaljw.kkd1@gmail.com>
Date: Sat, 16 Oct 2021 20:49:01 -0400
Subject: [PATCH 2/2] Prefer dl_iterate_phdr(3) over /proc/self/maps

Instead of manually iterating over /proc/self/maps, shift to using the
GNU/Linux extension function: dl_iterate_phdr()

This also helps in getting around weird problems involving shiftfs + lxd
https://travis-ci.community/t/procfs-provides-paths-outside-of-container/9525
---
 lib/gvc/gvconfig.c | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/lib/gvc/gvconfig.c b/lib/gvc/gvconfig.c
index 06c332670..9a7544635 100644
--- a/lib/gvc/gvconfig.c
+++ b/lib/gvc/gvconfig.c
@@ -10,6 +10,10 @@
 
 #include "config.h"
 
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
 #include <gvc/gvconfig.h>
 
 #include <ctype.h>
@@ -17,6 +21,9 @@
 #include	<string.h>
 
 #ifdef ENABLE_LTDL
+#ifdef __linux__
+#include <link.h>
+#endif
 #include	<sys/types.h>
 #ifdef _WIN32
 #include <windows.h>
@@ -258,12 +265,29 @@ static void gvconfig_write_library_config(GVC_t *gvc, char *path, gvplugin_libra
 #define DOTLIBS "/.libs"
 #define STRLEN(s) (sizeof(s)-1)
 
+#ifdef __linux__
+static int line_callback(struct dl_phdr_info *info, size_t size, void *line)
+{
+   const char *path = info->dlpi_name;
+   char *tmp = strstr(path, "/libgvc.");
+   if (tmp) {
+        *tmp = 0;
+        /* Check for real /lib dir. Don't accept pre-install /.libs */
+        if (strcmp(strrchr(path,'/'), DOTLIBS) != 0) {
+            memmove(line, path, strlen(path) + 1);  /* use line buffer for result */
+            strcat(line, "/graphviz");  /* plugins are in "graphviz" subdirectory */
+            return 1;
+        }
+   }
+   return 0;
+}
+#endif
+
 char * gvconfig_libdir(GVC_t * gvc)
 {
     static char line[BSZ];
     static char *libdir;
     static boolean dirShown = 0; 
-    char *tmp;
 
     if (!libdir) {
         libdir=getenv("GVBINDIR");
@@ -295,6 +319,7 @@ char * gvconfig_libdir(GVC_t * gvc)
 	    uint32_t i, c = _dyld_image_count();
 	    size_t len, ind;
 	    const char* path;
+	    char *tmp;
 	    for (i = 0; i < c; ++i) {
 		path = _dyld_get_image_name(i);
 		tmp = strstr(path, "/libgvc.");
@@ -320,9 +345,13 @@ char * gvconfig_libdir(GVC_t * gvc)
 		    break;
 		}
 	    }
+#else
+#ifdef __linux__
+	    dl_iterate_phdr(line_callback, line);
+	    libdir = line;
 #else
 	    FILE* f = fopen ("/proc/self/maps", "r");
-	    char* path;
+	    char *path, *tmp;
 	    if (f) {
 		while (!feof (f)) {
 		    if (!fgets (line, sizeof (line), f))
@@ -347,6 +376,7 @@ char * gvconfig_libdir(GVC_t * gvc)
 		fclose (f);
 	    }
 #endif
+#endif
 #endif
 	}
     }
-- 
GitLab

